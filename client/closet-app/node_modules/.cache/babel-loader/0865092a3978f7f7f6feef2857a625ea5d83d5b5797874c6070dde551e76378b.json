{"ast":null,"code":"// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length) code = path.charCodeAt(i);else if (code === 47 /*/*/) break;else code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) res += '/..';else res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) res += '/' + path.slice(lastSlash + 1, i);else res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0) path = arguments[i];else {\n        if (cwd === undefined) cwd = process.cwd();\n        path = cwd;\n      }\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0) return '/' + resolvedPath;else return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n  normalize: function normalize(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0) return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined) joined = arg;else joined += '/' + arg;\n      }\n    }\n    if (joined === undefined) return '.';\n    return posix.normalize(joined);\n  },\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n    if (from === to) return '';\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/) break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/) break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode) break;else if (fromCode === 47 /*/*/) lastCommonSep = i;\n    }\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0) out += '..';else out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/) ++toStart;\n      return to.slice(toStart);\n    }\n  },\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n  parse: function parse(path) {\n    assertPath(path);\n    var ret = {\n      root: '',\n      dir: '',\n      base: '',\n      ext: '',\n      name: ''\n    };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n    return ret;\n  },\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\nposix.posix = posix;\nmodule.exports = posix;","map":{"version":3,"names":["assertPath","path","TypeError","JSON","stringify","normalizeStringPosix","allowAboveRoot","res","lastSegmentLength","lastSlash","dots","code","i","length","charCodeAt","lastSlashIndex","lastIndexOf","slice","_format","sep","pathObject","dir","root","base","name","ext","posix","resolve","resolvedPath","resolvedAbsolute","cwd","arguments","undefined","process","normalize","isAbsolute","trailingSeparator","join","joined","arg","relative","from","to","fromStart","fromEnd","fromLen","toStart","toEnd","toLen","lastCommonSep","fromCode","toCode","out","_makeLong","dirname","hasRoot","end","matchedSlash","basename","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","parse","ret","delimiter","win32","module","exports"],"sources":["/Users/kristo/kristos-closet/client/closet-app/node_modules/path-browserify/index.js"],"sourcesContent":["// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}